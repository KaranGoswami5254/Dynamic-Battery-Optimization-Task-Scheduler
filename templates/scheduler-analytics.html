<!-- Scheduler Analytics Section - Add this to your existing page -->
{% extends "base.html" %}
{% block content %}
<div id="scheduler-analytics" class="analytics-section">
    <div class="analytics-header">
        <h2>üìä Scheduler Performance Analytics</h2>
        <p>Compare baseline vs optimized scheduler performance</p>
    </div>

    <!-- Controls -->
    <div class="analytics-controls">
        <div class="control-group">
            <button id="importReportBtn" class="btn btn-primary">
                üìÅ Import Report Data
            </button>
            <button id="generateReportBtn" class="btn btn-success">
                üìà Generate Comparison Report
            </button>
            <button id="exportReportBtn" class="btn btn-secondary">
                üíæ Export Report
            </button>
        </div>
        <div class="control-group">
            <input type="file" id="reportFileInput" accept=".json" style="display: none;">
            <div class="view-options">
                <label>View:</label>
                <select id="chartTypeSelect">
                    <option value="comparison">Performance Comparison</option>
                    <option value="timeline">Execution Timeline</option>
                    <option value="metrics">Detailed Metrics</option>
                </select>
            </div>
        </div>
    </div>

    <!-- Report Summary Cards -->
    <div class="summary-cards">
        <div class="card">
            <div class="card-header">
                <h3>Overall Improvement</h3>
            </div>
            <div class="card-body">
                <div class="improvement-value" id="overallImprovement">+0%</div>
                <div class="improvement-label">Performance Gain</div>
            </div>
        </div>
        <div class="card">
            <div class="card-header">
                <h3>Throughput</h3>
            </div>
            <div class="card-body">
                <div class="metric-comparison">
                    <span class="baseline-value" id="throughputBaseline">0</span>
                    <span class="optimized-value" id="throughputOptimized">0</span>
                </div>
                <div class="improvement-badge" id="throughputImprovement">+0%</div>
            </div>
        </div>
        <div class="card">
            <div class="card-header">
                <h3>Response Time</h3>
            </div>
            <div class="card-body">
                <div class="metric-comparison">
                    <span class="baseline-value" id="responseTimeBaseline">0ms</span>
                    <span class="optimized-value" id="responseTimeOptimized">0ms</span>
                </div>
                <div class="improvement-badge" id="responseTimeImprovement">+0%</div>
            </div>
        </div>
        <div class="card">
            <div class="card-header">
                <h3>CPU Utilization</h3>
            </div>
            <div class="card-body">
                <div class="metric-comparison">
                    <span class="baseline-value" id="cpuUtilBaseline">0%</span>
                    <span class="optimized-value" id="cpuUtilOptimized">0%</span>
                </div>
                <div class="improvement-badge" id="cpuUtilImprovement">+0%</div>
            </div>
        </div>
    </div>

    <!-- Main Visualization -->
    <div class="visualization-container">
        <div class="chart-container">
            <canvas id="performanceComparisonChart"></canvas>
        </div>
    </div>

    <!-- Detailed Metrics Table -->
    <div class="metrics-table-container">
        <h3>Detailed Performance Metrics</h3>
        <table id="metricsTable" class="metrics-table">
            <thead>
                <tr>
                    <th>Metric</th>
                    <th>Baseline</th>
                    <th>Optimized</th>
                    <th>Improvement</th>
                    <th>Status</th>
                </tr>
            </thead>
            <tbody>
                <!-- Will be populated by JavaScript -->
            </tbody>
        </table>
    </div>
</div>

<style>
/* Analytics Section Styles */
.analytics-section {
    background: #fff;
    border-radius: 10px;
    padding: 20px;
    margin: 20px 0;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}

.analytics-header {
    text-align: center;
    margin-bottom: 30px;
}

.analytics-header h2 {
    color: #2c3e50;
    margin-bottom: 5px;
}

.analytics-header p {
    color: #7f8c8d;
}

/* Controls */
.analytics-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    flex-wrap: wrap;
    gap: 15px;
}

.control-group {
    display: flex;
    gap: 10px;
    align-items: center;
}

.btn {
    padding: 10px 20px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-weight: 500;
    transition: all 0.3s ease;
}

.btn-primary {
    background: #3498db;
    color: white;
}

.btn-success {
    background: #27ae60;
    color: white;
}

.btn-secondary {
    background: #95a5a6;
    color: white;
}

.btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}

.view-options {
    display: flex;
    align-items: center;
    gap: 10px;
}

.view-options select {
    padding: 8px 12px;
    border: 1px solid #bdc3c7;
    border-radius: 5px;
}

/* Summary Cards */
.summary-cards {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 20px;
    margin-bottom: 30px;
}

.card {
    background: #f8f9fa;
    border-radius: 8px;
    padding: 15px;
    border-left: 4px solid #3498db;
}

.card-header h3 {
    margin: 0 0 10px 0;
    font-size: 14px;
    color: #7f8c8d;
    text-transform: uppercase;
}

.card-body {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.improvement-value {
    font-size: 24px;
    font-weight: bold;
    color: #27ae60;
}

.improvement-label {
    font-size: 12px;
    color: #7f8c8d;
}

.metric-comparison {
    display: flex;
    flex-direction: column;
    gap: 5px;
}

.baseline-value {
    font-size: 14px;
    color: #e74c3c;
    text-decoration: line-through;
}

.optimized-value {
    font-size: 16px;
    font-weight: bold;
    color: #27ae60;
}

.improvement-badge {
    background: #27ae60;
    color: white;
    padding: 4px 8px;
    border-radius: 12px;
    font-size: 12px;
    font-weight: bold;
}

/* Visualization */
.visualization-container {
    background: white;
    border: 1px solid #ecf0f1;
    border-radius: 8px;
    padding: 20px;
    margin-bottom: 30px;
}

.chart-container {
    position: relative;
    height: 400px;
    width: 100%;
}

/* Metrics Table */
.metrics-table-container {
    margin-top: 30px;
}

.metrics-table-container h3 {
    margin-bottom: 15px;
    color: #2c3e50;
}

.metrics-table {
    width: 100%;
    border-collapse: collapse;
    background: white;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

.metrics-table th,
.metrics-table td {
    padding: 12px 15px;
    text-align: left;
    border-bottom: 1px solid #ecf0f1;
}

.metrics-table th {
    background: #34495e;
    color: white;
    font-weight: 600;
}

.metrics-table tr:hover {
    background: #f8f9fa;
}

.status-improved {
    color: #27ae60;
    font-weight: bold;
}

.status-worsened {
    color: #e74c3c;
    font-weight: bold;
}

.status-neutral {
    color: #7f8c8d;
}

/* Fix for metrics table - add this to your existing CSS */
.metrics-table-container {
    margin-top: 30px;
    overflow-x: auto; /* Enable horizontal scrolling if needed */
}

.metrics-table {
    width: 100%;
    border-collapse: collapse;
    background: black;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    table-layout: auto; /* Change from fixed to auto */
    min-width: 600px; /* Ensure minimum width */
}

.metrics-table th,
.metrics-table td {
    padding: 12px 15px;
    text-align: left;
    border-bottom: 1px solid #ecf0f1;
    white-space: nowrap; /* Prevent text wrapping */
}

.metrics-table th {
    background: #34495e;
    color: white;
    font-weight: 600;
    position: sticky;
    top: 0;
}

.metrics-table tr:hover {
    background: none;
}

/* Ensure all columns have enough space */
.metrics-table th:nth-child(1),
.metrics-table td:nth-child(1) {
    min-width: 200px; /* Metric column wider */
}

.metrics-table th:nth-child(2),
.metrics-table td:nth-child(2),
.metrics-table th:nth-child(3),
.metrics-table td:nth-child(3) {
    min-width: 100px; /* Baseline/Optimized columns */
}

.metrics-table th:nth-child(4),
.metrics-table td:nth-child(4) {
    min-width: 120px; /* Improvement column */
}

.metrics-table th:nth-child(5),
.metrics-table td:nth-child(5) {
    min-width: 100px; /* Status column */
}
</style>

<script>
    // Global variables
    let currentReportData = null;
    let performanceChart = null;
    let autoRefreshInterval = null;
    
    // Initialize analytics after DOM is ready
    document.addEventListener('DOMContentLoaded', function() {
        console.log("‚úÖ DOM loaded - initializing analytics");
        initializeAnalytics();
    });
    
    async function initializeAnalytics() {
        console.log("‚úÖ initializeAnalytics() called");
        
        try {
            // Set up event listeners
            document.getElementById('importReportBtn').addEventListener('click', importReport);
            document.getElementById('generateReportBtn').addEventListener('click', generateReport);
            document.getElementById('exportReportBtn').addEventListener('click', exportReport);
            document.getElementById('reportFileInput').addEventListener('change', handleFileImport);
            document.getElementById('chartTypeSelect').addEventListener('change', updateChartType);

            console.log("‚úÖ Event listeners set up");
            
            // Wait for DOM to be fully ready
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // Fetch initial analytics data from backend
            await fetchBackendData();
            
            // Start auto-refresh (30 second intervals)
            startAutoRefresh();
            
        } catch (error) {
            console.error("‚ùå Error in initializeAnalytics:", error);
            showNotification("Failed to initialize analytics", "error");
        }
    }
    
    // Auto-refresh data every 30 seconds
    function startAutoRefresh() {
        // Clear any existing interval first
        stopAutoRefresh();
        
        console.log("üîÑ Starting auto-refresh (30s intervals)");
        autoRefreshInterval = setInterval(async () => {
            try {
                console.log("üîÑ Auto-refreshing data...");
                await fetchBackendData();
                showNotification("Data auto-refreshed", "info");
            } catch (error) {
                console.error("‚ùå Auto-refresh failed:", error);
            }
        }, 30000); // 30 seconds
    }
    
    function stopAutoRefresh() {
        if (autoRefreshInterval) {
            console.log("üõë Stopping auto-refresh");
            clearInterval(autoRefreshInterval);
            autoRefreshInterval = null;
        }
    }
    
    // Fetch scheduler analytics from backend
    async function fetchBackendData() {
        try {
            console.log("üîÑ Starting to fetch data from backend...");
            showNotification("Fetching latest analytics data...", "info");
            
            const response = await fetch('/scheduler-analytics-data');
            console.log("üì° Response status:", response.status);
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const backendData = await response.json();
            console.log("‚úÖ Backend data received successfully");
    
            if (backendData.error) {
                throw new Error(backendData.error);
            }
    
            loadReportData(backendData);
            showNotification("Analytics data loaded successfully!", "success");
            return true;

        } catch (err) {
            console.error("‚ùå Error fetching scheduler analytics:", err);
            showNotification("Error fetching analytics data: " + err.message, "error");
            return false;
        }
    }
    
    // Load analytics into frontend
    function loadReportData(data) {
        console.log("üìä Loading report data into frontend");
        currentReportData = data;
        updateSummaryCards();
        updateMetricsTable();
        renderPerformanceChart();
    }
    
    // Update summary cards
    function updateSummaryCards() {
        console.log("üîÑ Updating summary cards");
        
        if (!currentReportData || !currentReportData.summary) {
            console.error("‚ùå No summary data available");
            return;
        }
    
        const { baseline, optimized, overallImprovement } = currentReportData.summary;
        console.log("üìà Overall improvement:", overallImprovement);

        // Calculate individual improvements
        const throughputImp = ((optimized.throughput - baseline.throughput) / baseline.throughput * 100).toFixed(1);
        const responseTimeImp = ((baseline.responseTime - optimized.responseTime) / baseline.responseTime * 100).toFixed(1);
        const cpuUtilImp = ((baseline.cpuUtilization - optimized.cpuUtilization) / baseline.cpuUtilization * 100).toFixed(1);
    
        // Update DOM elements
        document.getElementById('overallImprovement').textContent = `+${overallImprovement}%`;
        document.getElementById('throughputBaseline').textContent = baseline.throughput.toFixed(2);
        document.getElementById('throughputOptimized').textContent = optimized.throughput.toFixed(2);
        document.getElementById('throughputImprovement').textContent = `+${throughputImp}%`;
        document.getElementById('responseTimeBaseline').textContent = `${baseline.responseTime.toFixed(2)}ms`;
        document.getElementById('responseTimeOptimized').textContent = `${optimized.responseTime.toFixed(2)}ms`;
        document.getElementById('responseTimeImprovement').textContent = `+${responseTimeImp}%`;
        document.getElementById('cpuUtilBaseline').textContent = `${baseline.cpuUtilization.toFixed(2)}`;
        document.getElementById('cpuUtilOptimized').textContent = `${optimized.cpuUtilization.toFixed(2)}`;
        document.getElementById('cpuUtilImprovement').textContent = `+${cpuUtilImp}%`;
        
        console.log("‚úÖ Summary cards updated");
    }
    
    // Update detailed metrics table
    function updateMetricsTable() {
        console.log("üîÑ Updating metrics table");
        
        if (!currentReportData || !currentReportData.summary || !currentReportData.summary.detailedMetrics) {
            console.error("‚ùå No detailed metrics data available");
            return;
        }

        const detailedMetrics = currentReportData.summary.detailedMetrics;
        const tableBody = document.querySelector('#metricsTable tbody');
        
        if (!tableBody) {
            console.error("‚ùå Metrics table body not found");
            return;
        }

        tableBody.innerHTML = '';

        detailedMetrics.forEach(metric => {
            const improvement = metric.improvement;
            const status = improvement > 0 ? 'status-improved' : 
                           improvement < 0 ? 'status-worsened' : 'status-neutral';
            const statusText = improvement > 0 ? 'Improved' : 
                               improvement < 0 ? 'Worsened' : 'No Change';

            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${metric.metric || 'N/A'}</td>
                <td>${formatMetricValue(metric.baseline)}</td>
                <td>${formatMetricValue(metric.optimized)}</td>
                <td class="${status}">${improvement > 0 ? '+' : ''}${improvement.toFixed(1)}%</td>
                <td class="${status}">${statusText}</td>
            `;
            tableBody.appendChild(row);
        });
        
        console.log("‚úÖ Metrics table updated");
    }

    // Helper function to format metric values
    function formatMetricValue(value) {
        if (value === null || value === undefined) return 'N/A';
        if (typeof value === 'number') {
            return value.toFixed(2);
        }
        return value.toString();
    }
    
    // Render performance comparison chart
    function renderPerformanceChart() {
        console.log("üîÑ Rendering performance chart");
        
        if (!currentReportData || !currentReportData.summary) {
            console.error("‚ùå No data for chart");
            return;
        }

        const ctx = document.getElementById('performanceComparisonChart').getContext('2d');

        // Destroy existing chart if it exists
        if (performanceChart) {
            performanceChart.destroy();
        }

        const { baseline, optimized } = currentReportData.summary;

        // Create normalized data for better visualization
        const chartData = {
            labels: ['Throughput', 'Response Time', 'Wait Time', 'CPU Utilization', 'Context Switches', 'Turnaround Time', 'Energy Used'],
            datasets: [
                {
                    label: 'Baseline Scheduler',
                    data: [
                        baseline.throughput, 
                        baseline.responseTime, 
                        baseline.waitTime, 
                        baseline.cpuUtilization, 
                        baseline.contextSwitches / 10,
                        baseline.turnaroundTime,
                        baseline.energyUsed * 10
                    ],
                    backgroundColor: 'rgba(231, 76, 60, 0.7)',
                    borderColor: 'rgba(231, 76, 60, 1)',
                    borderWidth: 1
                },
                {
                    label: 'Optimized Scheduler',
                    data: [
                        optimized.throughput, 
                        optimized.responseTime, 
                        optimized.waitTime, 
                        optimized.cpuUtilization, 
                        optimized.contextSwitches / 10,
                        optimized.turnaroundTime,
                        optimized.energyUsed * 10
                    ],
                    backgroundColor: 'rgba(39, 174, 96, 0.7)',
                    borderColor: 'rgba(39, 174, 96, 1)',
                    borderWidth: 1
                }
            ]
        };

        performanceChart = new Chart(ctx, {
            type: 'bar',
            data: chartData,
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: { 
                        beginAtZero: true, 
                        title: { display: true, text: 'Values' }
                    }
                },
                plugins: {
                    title: { display: true, text: 'Scheduler Performance Comparison', font: { size: 16 } },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label + ': ';
                                const dataIndex = context.dataIndex;
                                let value = context.parsed.y;
                                
                                // Reverse scaling for tooltip display
                                if (dataIndex === 4) { // Context Switches
                                    value = value * 10;
                                    label += value.toFixed(0) + ' switches';
                                } else if (dataIndex === 6) { // Energy Used
                                    value = value / 10;
                                    label += value.toFixed(2) + ' energy';
                                } else if (dataIndex === 0) {
                                    label += value.toFixed(2) + ' tasks/sec';
                                } else if (dataIndex === 1 || dataIndex === 2 || dataIndex === 5) {
                                    label += value.toFixed(2) + ' ms';
                                } else if (dataIndex === 3) {
                                    label += value.toFixed(2) + ' units';
                                }
                                
                                return label;
                            }
                        }
                    }
                }
            }
        });
        
        console.log("‚úÖ Performance chart rendered");
    }
    
    // Report file handling functions
    function importReport() { 
        document.getElementById('reportFileInput').click(); 
    }
    
    function handleFileImport(event) {
        const file = event.target.files[0];
        if (!file) return;
    
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const reportData = JSON.parse(e.target.result);
                loadReportData(reportData);
                showNotification('Report imported successfully!', 'success');
            } catch (error) {
                showNotification('Error parsing report file', 'error');
                console.error('Error parsing report:', error);
            }
        };
        reader.readAsText(file);
    }
    
    function generateReport() {
        console.log("üîÑ Manual refresh triggered");
        fetchBackendData();
    }
    
    function exportReport() {
        if (!currentReportData) {
            showNotification('No report data to export', 'error');
            return;
        }
    
        // Create CSV content
        const csvContent = generateCSVContent();
        
        // Create and download CSV file
        const dataBlob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(dataBlob);
        link.download = `scheduler-report-${new Date().toISOString().split('T')[0]}.csv`;
        link.click();
        
        showNotification('CSV report exported successfully!', 'success');
    }
    
    // Generate CSV content from report data
    function generateCSVContent() {
        const { summary, ordinary, optimized, timestamp } = currentReportData;
        const { baseline, optimized: opt, overallImprovement, detailedMetrics } = summary;
    
        let csv = 'Scheduler Performance Analysis Report\n';
        csv += `Generated: ${timestamp}\n\n`;
    
        // Summary Section
        csv += 'OVERALL SUMMARY\n';
        csv += `Overall Improvement,${overallImprovement}%\n\n`;
    
        // Key Metrics Comparison
        csv += 'KEY METRICS COMPARISON\n';
        csv += 'Metric,Baseline,Optimized,Improvement,Status\n';
        
        detailedMetrics.forEach(metric => {
            csv += `"${metric.metric}",${metric.baseline},${metric.optimized},${metric.improvement.toFixed(1)}%,${metric.status}\n`;
        });
        
        csv += '\n';
    
        // Performance Summary
        csv += 'PERFORMANCE SUMMARY\n';
        csv += 'Category,Metric,Baseline,Optimized,Improvement\n';
        
        // Throughput
        csv += `Performance,Throughput (tasks/sec),${baseline.throughput},${opt.throughput},${((opt.throughput - baseline.throughput) / baseline.throughput * 100).toFixed(1)}%\n`;
        
        // Response Times
        csv += `Performance,Response Time (ms),${baseline.responseTime},${opt.responseTime},${((baseline.responseTime - opt.responseTime) / baseline.responseTime * 100).toFixed(1)}%\n`;
        csv += `Performance,Wait Time (ms),${baseline.waitTime},${opt.waitTime},${((baseline.waitTime - opt.waitTime) / baseline.waitTime * 100).toFixed(1)}%\n`;
        csv += `Performance,Turnaround Time (ms),${baseline.turnaroundTime},${opt.turnaroundTime},${((baseline.turnaroundTime - opt.turnaroundTime) / baseline.turnaroundTime * 100).toFixed(1)}%\n`;
        
        // Efficiency Metrics
        csv += `Efficiency,CPU Utilization,${baseline.cpuUtilization},${opt.cpuUtilization},${((baseline.cpuUtilization - opt.cpuUtilization) / baseline.cpuUtilization * 100).toFixed(1)}%\n`;
        csv += `Efficiency,Context Switches,${baseline.contextSwitches},${opt.contextSwitches},${((baseline.contextSwitches - opt.contextSwitches) / baseline.contextSwitches * 100).toFixed(1)}%\n`;
        csv += `Efficiency,Energy Used,${baseline.energyUsed},${opt.energyUsed},${((baseline.energyUsed - opt.energyUsed) / baseline.energyUsed * 100).toFixed(1)}%\n`;
        
        csv += '\n';
    
        // Task Data - Baseline
        csv += 'BASELINE SCHEDULER TASK DETAILS\n';
        csv += 'Task ID,Name,Execution Time (ms),Wait Time (ms),Turnaround Time (ms),Energy Used\n';
        ordinary.forEach(task => {
            csv += `${task.id},"${task.name}",${task.execution_time},${task.wait_time},${task.turnaround_time},${task.energy_used}\n`;
        });
        
        csv += '\n';
    
        // Task Data - Optimized
        csv += 'OPTIMIZED SCHEDULER TASK DETAILS\n';
        csv += 'Task ID,Name,Execution Time (ms),Wait Time (ms),Turnaround Time (ms),Energy Used\n';
        optimized.forEach(task => {
            csv += `${task.id},"${task.name}",${task.execution_time},${task.wait_time},${task.turnaround_time},${task.energy_used}\n`;
        });
    
        return csv;
    }
    
    function updateChartType() {
        if (currentReportData) {
            renderPerformanceChart();
        }
    }
    
    // Simple notification function
    function showNotification(message, type) {
        // Remove any existing notifications
        const existingNotifications = document.querySelectorAll('.custom-notification');
        existingNotifications.forEach(notif => notif.remove());
    
        const notification = document.createElement('div');
        notification.className = 'custom-notification';
        notification.style.cssText = `
            position: fixed; 
            top: 20px; 
            right: 20px; 
            padding: 15px 20px; 
            border-radius: 5px;
            color: white; 
            font-weight: 500; 
            z-index: 10000;
            background: ${type === 'success' ? '#27ae60' : type === 'error' ? '#e74c3c' : '#3498db'};
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            transition: all 0.3s ease;
        `;
        notification.textContent = message;
        document.body.appendChild(notification);
        
        // Animate in
        setTimeout(() => {
            notification.style.transform = 'translateX(0)';
        }, 10);
    
        // Remove after 3 seconds
        setTimeout(() => {
            notification.style.transform = 'translateX(100%)';
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 300);
        }, 3000);
    }
    
    // Make functions globally available
    window.schedulerAnalytics = { 
        loadReportData, 
        generateReport, 
        exportReport,
        startAutoRefresh,
        stopAutoRefresh
    };
</script>
    
{% endblock %}
<!-- Scheduler Analytics Section - Add this to your existing page -->
{% extends "base.html" %}
{% block content %}
<div id="scheduler-analytics" class="analytics-section">
    <div class="analytics-header">
        <h2>üìä Scheduler Performance Analytics</h2>
        <p>Compare baseline vs optimized scheduler performance</p>
    </div>

    <!-- Controls -->
    <div class="analytics-controls">
        <div class="control-group">
            <button id="importReportBtn" class="btn btn-primary">
                üìÅ Import Report Data
            </button>
            <button id="generateReportBtn" class="btn btn-success">
                üìà Generate Comparison Report
            </button>
            <button id="exportReportBtn" class="btn btn-secondary">
                üíæ Export Report
            </button>
        </div>
        <div class="control-group">
            <input type="file" id="reportFileInput" accept=".json" style="display: none;">
            <div class="view-options">
                <label>View:</label>
                <select id="chartTypeSelect">
                    <option value="comparison">Performance Comparison</option>
                    <option value="timeline">Execution Timeline</option>
                    <option value="metrics">Detailed Metrics</option>
                </select>
            </div>
        </div>
    </div>

    <!-- Report Summary Cards -->
    <div class="summary-cards">
        <div class="card">
            <div class="card-header">
                <h3>Overall Improvement</h3>
            </div>
            <div class="card-body">
                <div class="improvement-value" id="overallImprovement">+0%</div>
                <div class="improvement-label">Performance Gain</div>
            </div>
        </div>
        <div class="card">
            <div class="card-header">
                <h3>Throughput</h3>
            </div>
            <div class="card-body">
                <div class="metric-comparison">
                    <span class="baseline-value" id="throughputBaseline">0</span>
                    <span class="optimized-value" id="throughputOptimized">0</span>
                </div>
                <div class="improvement-badge" id="throughputImprovement">+0%</div>
            </div>
        </div>
        <div class="card">
            <div class="card-header">
                <h3>Response Time</h3>
            </div>
            <div class="card-body">
                <div class="metric-comparison">
                    <span class="baseline-value" id="responseTimeBaseline">0ms</span>
                    <span class="optimized-value" id="responseTimeOptimized">0ms</span>
                </div>
                <div class="improvement-badge" id="responseTimeImprovement">+0%</div>
            </div>
        </div>
        <div class="card">
            <div class="card-header">
                <h3>CPU Utilization</h3>
            </div>
            <div class="card-body">
                <div class="metric-comparison">
                    <span class="baseline-value" id="cpuUtilBaseline">0%</span>
                    <span class="optimized-value" id="cpuUtilOptimized">0%</span>
                </div>
                <div class="improvement-badge" id="cpuUtilImprovement">+0%</div>
            </div>
        </div>
    </div>

    <!-- Main Visualization -->
    <div class="visualization-container">
        <div class="chart-container">
            <canvas id="performanceComparisonChart"></canvas>
        </div>
    </div>

    <!-- Detailed Metrics Table -->
    <div class="metrics-table-container">
        <h3>Detailed Performance Metrics</h3>
        <table id="metricsTable" class="metrics-table">
            <thead>
                <tr>
                    <th>Metric</th>
                    <th>Baseline</th>
                    <th>Optimized</th>
                    <th>Improvement</th>
                    <th>Status</th>
                </tr>
            </thead>
            <tbody>
                <!-- Will be populated by JavaScript -->
            </tbody>
        </table>
    </div>
</div>

<style>
/* Analytics Section Styles */
.analytics-section {
    background: #fff;
    border-radius: 10px;
    padding: 20px;
    margin: 20px 0;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}

.analytics-header {
    text-align: center;
    margin-bottom: 30px;
}

.analytics-header h2 {
    color: #2c3e50;
    margin-bottom: 5px;
}

.analytics-header p {
    color: #7f8c8d;
}

/* Controls */
.analytics-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    flex-wrap: wrap;
    gap: 15px;
}

.control-group {
    display: flex;
    gap: 10px;
    align-items: center;
}

.btn {
    padding: 10px 20px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-weight: 500;
    transition: all 0.3s ease;
}

.btn-primary {
    background: #3498db;
    color: white;
}

.btn-success {
    background: #27ae60;
    color: white;
}

.btn-secondary {
    background: #95a5a6;
    color: white;
}

.btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}

.view-options {
    display: flex;
    align-items: center;
    gap: 10px;
}

.view-options select {
    padding: 8px 12px;
    border: 1px solid #bdc3c7;
    border-radius: 5px;
}

/* Summary Cards */
.summary-cards {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 20px;
    margin-bottom: 30px;
}

.card {
    background: #f8f9fa;
    border-radius: 8px;
    padding: 15px;
    border-left: 4px solid #3498db;
}

.card-header h3 {
    margin: 0 0 10px 0;
    font-size: 14px;
    color: #7f8c8d;
    text-transform: uppercase;
}

.card-body {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.improvement-value {
    font-size: 24px;
    font-weight: bold;
    color: #27ae60;
}

.improvement-label {
    font-size: 12px;
    color: #7f8c8d;
}

.metric-comparison {
    display: flex;
    flex-direction: column;
    gap: 5px;
}

.baseline-value {
    font-size: 14px;
    color: #e74c3c;
    text-decoration: line-through;
}

.optimized-value {
    font-size: 16px;
    font-weight: bold;
    color: #27ae60;
}

.improvement-badge {
    background: #27ae60;
    color: white;
    padding: 4px 8px;
    border-radius: 12px;
    font-size: 12px;
    font-weight: bold;
}

/* Visualization */
.visualization-container {
    background: white;
    border: 1px solid #ecf0f1;
    border-radius: 8px;
    padding: 20px;
    margin-bottom: 30px;
}

.chart-container {
    position: relative;
    height: 400px;
    width: 100%;
}

/* Metrics Table */
.metrics-table-container {
    margin-top: 30px;
}

.metrics-table-container h3 {
    margin-bottom: 15px;
    color: #2c3e50;
}

.metrics-table {
    width: 100%;
    border-collapse: collapse;
    background: white;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

.metrics-table th,
.metrics-table td {
    padding: 12px 15px;
    text-align: left;
    border-bottom: 1px solid #ecf0f1;
}

.metrics-table th {
    background: #34495e;
    color: white;
    font-weight: 600;
}

.metrics-table tr:hover {
    background: #f8f9fa;
}

.status-improved {
    color: #27ae60;
    font-weight: bold;
}

.status-worsened {
    color: #e74c3c;
    font-weight: bold;
}

.status-neutral {
    color: #7f8c8d;
}

/* Fix for metrics table - add this to your existing CSS */
.metrics-table-container {
    margin-top: 30px;
    overflow-x: auto; /* Enable horizontal scrolling if needed */
}

.metrics-table {
    width: 100%;
    border-collapse: collapse;
    background: black;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    table-layout: auto; /* Change from fixed to auto */
    min-width: 600px; /* Ensure minimum width */
}

.metrics-table th,
.metrics-table td {
    padding: 12px 15px;
    text-align: left;
    border-bottom: 1px solid #ecf0f1;
    white-space: nowrap; /* Prevent text wrapping */
}

.metrics-table th {
    background: #34495e;
    color: white;
    font-weight: 600;
    position: sticky;
    top: 0;
}

.metrics-table tr:hover {
    background: none;
}

/* Ensure all columns have enough space */
.metrics-table th:nth-child(1),
.metrics-table td:nth-child(1) {
    min-width: 200px; /* Metric column wider */
}

.metrics-table th:nth-child(2),
.metrics-table td:nth-child(2),
.metrics-table th:nth-child(3),
.metrics-table td:nth-child(3) {
    min-width: 100px; /* Baseline/Optimized columns */
}

.metrics-table th:nth-child(4),
.metrics-table td:nth-child(4) {
    min-width: 120px; /* Improvement column */
}

.metrics-table th:nth-child(5),
.metrics-table td:nth-child(5) {
    min-width: 100px; /* Status column */
}
</style>

<script>
    // Global variables
    let currentReportData = null;
    let performanceChart = null;
    
    // Initialize analytics after DOM is ready
    document.addEventListener('DOMContentLoaded', function() {
        initializeAnalytics();
    });
    
    // Auto-refresh data every 30 seconds
function startAutoRefresh() {
    setInterval(async () => {
        console.log("üîÑ Auto-refreshing data...");
        await fetchBackendData();
        // Optional: show a subtle notification
        showNotification("Data auto-refreshed", "info");
    }, 30000); // 30 seconds
}

// Initialize analytics after DOM is ready
document.addEventListener('DOMContentLoaded', function() {
    initializeAnalytics();
});

async function initializeAnalytics() {
    // Set up event listeners
    document.getElementById('importReportBtn').addEventListener('click', importReport);
    document.getElementById('generateReportBtn').addEventListener('click', generateReport);
    document.getElementById('exportReportBtn').addEventListener('click', exportReport);
    document.getElementById('reportFileInput').addEventListener('change', handleFileImport);
    document.getElementById('chartTypeSelect').addEventListener('change', updateChartType);

    // Fetch initial analytics data from backend
    await fetchBackendData();
    
    // Start auto-refresh (30 second intervals)
    startAutoRefresh();
}
    
    // Fetch scheduler analytics from backend
    async function fetchBackendData() {
        try {
            showNotification("Fetching latest analytics data...", "info");
            const response = await fetch('/scheduler-analytics-data');
            const backendData = await response.json();
    
            if (backendData.error) {
                showNotification("Failed to load analytics data from server", "error");
                return;
            }
    
            console.log("Backend data received:", backendData);
            loadReportData(backendData);
            showNotification("Analytics data loaded successfully!", "success");
    
        } catch (err) {
            console.error("Error fetching scheduler analytics:", err);
            showNotification("Error fetching analytics data", "error");
        }
    }
    
    // Load analytics into frontend - FIXED: Use real backend data directly
    function loadReportData(data) {
        currentReportData = data;
        updateSummaryCards();
        updateMetricsTable();
        renderPerformanceChart();
    }
    
    // Update summary cards - FIXED: Use real backend data
    function updateSummaryCards() {
        if (!currentReportData || !currentReportData.summary) return;
    
        const { baseline, optimized, overallImprovement } = currentReportData.summary;
    
        // Calculate individual improvements
        const throughputImp = ((optimized.throughput - baseline.throughput) / baseline.throughput * 100).toFixed(1);
        const responseTimeImp = ((baseline.responseTime - optimized.responseTime) / baseline.responseTime * 100).toFixed(1);
        const cpuUtilImp = ((baseline.cpuUtilization - optimized.cpuUtilization) / baseline.cpuUtilization * 100).toFixed(1);
    
        // Update DOM elements
        document.getElementById('overallImprovement').textContent = `+${overallImprovement}%`;
        
        document.getElementById('throughputBaseline').textContent = baseline.throughput.toFixed(2);
        document.getElementById('throughputOptimized').textContent = optimized.throughput.toFixed(2);
        document.getElementById('throughputImprovement').textContent = `+${throughputImp}%`;
    
        document.getElementById('responseTimeBaseline').textContent = `${baseline.responseTime.toFixed(2)}ms`;
        document.getElementById('responseTimeOptimized').textContent = `${optimized.responseTime.toFixed(2)}ms`;
        document.getElementById('responseTimeImprovement').textContent = `+${responseTimeImp}%`;
    
        document.getElementById('cpuUtilBaseline').textContent = `${baseline.cpuUtilization.toFixed(2)}`;
        document.getElementById('cpuUtilOptimized').textContent = `${optimized.cpuUtilization.toFixed(2)}`;
        document.getElementById('cpuUtilImprovement').textContent = `+${cpuUtilImp}%`;
    }
    
    // Update detailed metrics table - FIXED: Use detailedMetrics from backend
    // Update detailed metrics table - FIXED: Properly use detailedMetrics from backend
    // Add this at the beginning of updateMetricsTable() for debugging
    console.log("=== DEBUG METRICS DATA ===");
    console.log("Full currentReportData:", currentReportData);
    console.log("Summary:", currentReportData?.summary);
    console.log("Detailed Metrics:", currentReportData?.summary?.detailedMetrics);
    console.log("=== END DEBUG ===");
    function updateMetricsTable() {
    if (!currentReportData || !currentReportData.summary || !currentReportData.summary.detailedMetrics) {
        console.error("No detailed metrics data available:", currentReportData);
        return;
    }

    const detailedMetrics = currentReportData.summary.detailedMetrics;
    const tableBody = document.querySelector('#metricsTable tbody');
    
    if (!tableBody) {
        console.error("Metrics table body not found");
        return;
    }

    tableBody.innerHTML = '';

    console.log("Rendering detailed metrics:", detailedMetrics);

    detailedMetrics.forEach(metric => {
        console.log("Processing metric:", metric);
        
        const improvement = metric.improvement;
        const status = improvement > 0 ? 'status-improved' : 
                       improvement < 0 ? 'status-worsened' : 'status-neutral';
        const statusText = improvement > 0 ? 'Improved' : 
                           improvement < 0 ? 'Worsened' : 'No Change';

        const row = document.createElement('tr');
        row.innerHTML = `
            <td>${metric.metric || 'N/A'}</td>
            <td>${formatMetricValue(metric.baseline)}</td>
            <td>${formatMetricValue(metric.optimized)}</td>
            <td class="${status}">${improvement > 0 ? '+' : ''}${improvement.toFixed(1)}%</td>
            <td class="${status}">${statusText}</td>
        `;
        tableBody.appendChild(row);
    });
}

// Helper function to format metric values
function formatMetricValue(value) {
    if (value === null || value === undefined) return 'N/A';
    if (typeof value === 'number') {
        return value.toFixed(2);
    }
    return value.toString();
}
    
    // Render performance comparison chart - FIXED: Use real backend data
    // Render performance comparison chart - FIXED: Proper scaling for different metrics
function renderPerformanceChart() {
    if (!currentReportData || !currentReportData.summary) return;

    const ctx = document.getElementById('performanceComparisonChart').getContext('2d');

    if (performanceChart) {
        performanceChart.destroy();
    }

    const { baseline, optimized } = currentReportData.summary;

    // Create normalized data for better visualization
    const chartData = {
        labels: ['Throughput', 'Response Time', 'Wait Time', 'CPU Utilization', 'Context Switches', 'Turnaround Time', 'Energy Used'],
        datasets: [
            {
                label: 'Baseline Scheduler',
                data: [
                    baseline.throughput, 
                    baseline.responseTime, 
                    baseline.waitTime, 
                    baseline.cpuUtilization, 
                    baseline.contextSwitches / 10, // Scale down context switches
                    baseline.turnaroundTime,
                    baseline.energyUsed * 10 // Scale up energy for visibility
                ],
                backgroundColor: 'rgba(231, 76, 60, 0.7)',
                borderColor: 'rgba(231, 76, 60, 1)',
                borderWidth: 1
            },
            {
                label: 'Optimized Scheduler',
                data: [
                    optimized.throughput, 
                    optimized.responseTime, 
                    optimized.waitTime, 
                    optimized.cpuUtilization, 
                    optimized.contextSwitches / 10, // Scale down context switches
                    optimized.turnaroundTime,
                    optimized.energyUsed * 10 // Scale up energy for visibility
                ],
                backgroundColor: 'rgba(39, 174, 96, 0.7)',
                borderColor: 'rgba(39, 174, 96, 1)',
                borderWidth: 1
            }
        ]
    };

    performanceChart = new Chart(ctx, {
        type: 'bar',
        data: chartData,
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: { 
                    beginAtZero: true, 
                    title: { display: true, text: 'Values' },
                    ticks: {
                        callback: function(value, index, values) {
                            // Custom formatting for scaled values
                            const labelIndex = this.chart.scales.x.getLabelForValue(index);
                            if (labelIndex === 4) { // Context Switches
                                return value * 10; // Reverse the scaling for display
                            } else if (labelIndex === 6) { // Energy Used
                                return (value / 10).toFixed(1); // Reverse the scaling for display
                            }
                            return value.toFixed(1);
                        }
                    }
                }
            },
            plugins: {
                title: { display: true, text: 'Scheduler Performance Comparison', font: { size: 16 } },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            let label = context.dataset.label + ': ';
                            const dataIndex = context.dataIndex;
                            let value = context.parsed.y;
                            
                            // Reverse scaling for tooltip display
                            if (dataIndex === 4) { // Context Switches
                                value = value * 10;
                                label += value.toFixed(0) + ' switches';
                            } else if (dataIndex === 6) { // Energy Used
                                value = value / 10;
                                label += value.toFixed(2) + ' energy';
                            } else if (dataIndex === 0) {
                                label += value.toFixed(2) + ' tasks/sec';
                            } else if (dataIndex === 1 || dataIndex === 2 || dataIndex === 5) {
                                label += value.toFixed(2) + ' ms';
                            } else if (dataIndex === 3) {
                                label += value.toFixed(2) + ' units';
                            }
                            
                            return label;
                        }
                    }
                }
            }
        }
    });
}
    
    // Report file handling functions
    function importReport() { 
        document.getElementById('reportFileInput').click(); 
    }
    
    function handleFileImport(event) {
        const file = event.target.files[0];
        if (!file) return;
    
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const reportData = JSON.parse(e.target.result);
                loadReportData(reportData);
                showNotification('Report imported successfully!', 'success');
            } catch (error) {
                showNotification('Error parsing report file', 'error');
                console.error('Error parsing report:', error);
            }
        };
        reader.readAsText(file);
    }
    
    function generateReport() {
        fetchBackendData();
    }
    
    function exportReport() {
        if (!currentReportData) {
            showNotification('No report data to export', 'error');
            return;
        }
    
        // Create CSV content
        const csvContent = generateCSVContent();
        
        // Create and download CSV file
        const dataBlob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(dataBlob);
        link.download = `scheduler-report-${new Date().toISOString().split('T')[0]}.csv`;
        link.click();
        
        showNotification('CSV report exported successfully!', 'success');
    }
    
    // Generate CSV content from report data
    function generateCSVContent() {
        const { summary, ordinary, optimized, timestamp } = currentReportData;
        const { baseline, optimized: opt, overallImprovement, detailedMetrics } = summary;
    
        let csv = 'Scheduler Performance Analysis Report\n';
        csv += `Generated: ${timestamp}\n\n`;
    
        // Summary Section
        csv += 'OVERALL SUMMARY\n';
        csv += `Overall Improvement,${overallImprovement}%\n\n`;
    
        // Key Metrics Comparison
        csv += 'KEY METRICS COMPARISON\n';
        csv += 'Metric,Baseline,Optimized,Improvement,Status\n';
        
        detailedMetrics.forEach(metric => {
            csv += `"${metric.metric}",${metric.baseline},${metric.optimized},${metric.improvement.toFixed(1)}%,${metric.status}\n`;
        });
        
        csv += '\n';
    
        // Performance Summary
        csv += 'PERFORMANCE SUMMARY\n';
        csv += 'Category,Metric,Baseline,Optimized,Improvement\n';
        
        // Throughput
        csv += `Performance,Throughput (tasks/sec),${baseline.throughput},${opt.throughput},${((opt.throughput - baseline.throughput) / baseline.throughput * 100).toFixed(1)}%\n`;
        
        // Response Times
        csv += `Performance,Response Time (ms),${baseline.responseTime},${opt.responseTime},${((baseline.responseTime - opt.responseTime) / baseline.responseTime * 100).toFixed(1)}%\n`;
        csv += `Performance,Wait Time (ms),${baseline.waitTime},${opt.waitTime},${((baseline.waitTime - opt.waitTime) / baseline.waitTime * 100).toFixed(1)}%\n`;
        csv += `Performance,Turnaround Time (ms),${baseline.turnaroundTime},${opt.turnaroundTime},${((baseline.turnaroundTime - opt.turnaroundTime) / baseline.turnaroundTime * 100).toFixed(1)}%\n`;
        
        // Efficiency Metrics
        csv += `Efficiency,CPU Utilization,${baseline.cpuUtilization},${opt.cpuUtilization},${((baseline.cpuUtilization - opt.cpuUtilization) / baseline.cpuUtilization * 100).toFixed(1)}%\n`;
        csv += `Efficiency,Context Switches,${baseline.contextSwitches},${opt.contextSwitches},${((baseline.contextSwitches - opt.contextSwitches) / baseline.contextSwitches * 100).toFixed(1)}%\n`;
        csv += `Efficiency,Energy Used,${baseline.energyUsed},${opt.energyUsed},${((baseline.energyUsed - opt.energyUsed) / baseline.energyUsed * 100).toFixed(1)}%\n`;
        
        csv += '\n';
    
        // Task Data - Baseline
        csv += 'BASELINE SCHEDULER TASK DETAILS\n';
        csv += 'Task ID,Name,Execution Time (ms),Wait Time (ms),Turnaround Time (ms),Energy Used\n';
        ordinary.forEach(task => {
            csv += `${task.id},"${task.name}",${task.execution_time},${task.wait_time},${task.turnaround_time},${task.energy_used}\n`;
        });
        
        csv += '\n';
    
        // Task Data - Optimized
        csv += 'OPTIMIZED SCHEDULER TASK DETAILS\n';
        csv += 'Task ID,Name,Execution Time (ms),Wait Time (ms),Turnaround Time (ms),Energy Used\n';
        optimized.forEach(task => {
            csv += `${task.id},"${task.name}",${task.execution_time},${task.wait_time},${task.turnaround_time},${task.energy_used}\n`;
        });
    
        return csv;
    }
    
    function updateChartType() {
        if (currentReportData) {
            renderPerformanceChart();
        }
    }
    
    // Simple notification function
    function showNotification(message, type) {
        // Remove any existing notifications
        const existingNotifications = document.querySelectorAll('.custom-notification');
        existingNotifications.forEach(notif => notif.remove());
    
        const notification = document.createElement('div');
        notification.className = 'custom-notification';
        notification.style.cssText = `
            position: fixed; 
            top: 20px; 
            right: 20px; 
            padding: 15px 20px; 
            border-radius: 5px;
            color: white; 
            font-weight: 500; 
            z-index: 10000;
            background: ${type === 'success' ? '#27ae60' : type === 'error' ? '#e74c3c' : '#3498db'};
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            transition: all 0.3s ease;
        `;
        notification.textContent = message;
        document.body.appendChild(notification);
        
        // Animate in
        setTimeout(() => {
            notification.style.transform = 'translateX(0)';
        }, 10);
    
        // Remove after 3 seconds
        setTimeout(() => {
            notification.style.transform = 'translateX(100%)';
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 300);
        }, 3000);
    }
    
    // Make functions globally available
    window.schedulerAnalytics = { loadReportData, generateReport, exportReport };
</script>
    
{% endblock %}